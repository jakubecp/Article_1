rm(list = ls())
library (rgbif)
library (raster)
library (maptools)
library (dismo)
library (rgdal)
library (XML)
library (rgdal)
library (sqldf)
library (maps)
library (testthat)
library (adehabitatHS)
library (roxygen2)
data(wrld_simpl) #create the World map with borders
occ_search(scientificName = "Nicrophorus antennatus",
hasCoordinate= TRUE, limit = 500)
n.ant<- occ_search(scientificName = "Nicrophorus antennatus",
hasCoordinate= TRUE, limit = 500)
#coordinates of observations (filter out NAs and obvious mistakes!)
coord <- data.frame (long = n.ant$data$decimalLongitude ,
lat= n.ant$data$decimalLatitude)
X11()
plot (coord)
plot (wrld_simpl, add=T)
plot (coord, xlim=(10,20))
plot (wrld_simpl, add=T)
plot (coord, xlim=c(10,20))
plot (wrld_simpl, add=T)
plot (coord, xlim=c(0,20), ylim=c(30,50))
plot (wrld_simpl, add=T)
View(coord)
View(coord)
setwd ("C:/Users/jakubecp/Dropbox/SGEM_2015/Article_1")
cz.nic.raw = read.csv (nicr.czech.csv, header= TRUE, sep=",")
cz.nic.raw = read.csv ("nicr.czech.csv", header= TRUE, sep=",")
View(cz.nic.raw)
View(cz.nic.raw)
cz.nic.raw = read.csv ("nicr.czech.csv", header= TRUE, sep=";")
View(cz.nic.raw)
View(cz.nic.raw)
install.packages ("celestial")
library (celestial)
head(cz.nic.raw)
setwd ("C:/Users/jakubecp/Dropbox/SGEM_2015/Article_1")
cz.nic.raw = read.csv ("nicr.czech.csv", header= TRUE, sep=";")
head(cz.nic.raw)
lat = dms2deg ("cz.nic.raw$lat", sep="°´""" )
lat = dms2deg ("cz.nic.raw$lat", sep="°´"")
cz.nic.raw = read.csv ("nicr.czech.csv", header= TRUE, sep=";")
head(cz.nic.raw)
cz.nic.raw = read.csv ("nicr.czech.csv", header= TRUE, sep=";")
head(cz.nic.raw)
head(cz.nic.raw)
lat = dms2deg ("cz.nic.raw$lat", sep="DMS")
lat = dms2deg ("cz.nic.raw$lat", sep="DMS")
dms2deg ("cz.nic.raw$lat", sep="DMS")
cz.nic.raw = read.csv ("nicr.czech.csv", header= TRUE, sep=";")
head(cz.nic.raw)
lat=dms2deg ("cz.nic.raw4lat", sep="DMS")
lat=dms2deg ("49D56M48.183S", sep="DMS")
lat
convert (cz.nic.raw$lat)
convert<-function(coord){
tmp1=strsplit(coord,"°")
tmp2=strsplit(tmp1[[1]][2],"'")
tmp3=strsplit(tmp2[[1]][2],"\"")
dec=c(as.numeric(tmp1[[1]][1]),as.numeric(tmp2[[1]][1]),as.numeric(tmp3[[1]]))
c<-abs(dec[1])+dec[2]/60+dec[3]/3600
c<-ifelse(dec[1]<0,-c,c)
return(c)
}
convert (cz.nic.raw$lat)
convert<-function(coord){
tmp1=strsplit(coord,"D")
tmp2=strsplit(tmp1[[1]][2],"M")
tmp3=strsplit(tmp2[[1]][2],"\S")
dec=c(as.numeric(tmp1[[1]][1]),as.numeric(tmp2[[1]][1]),as.numeric(tmp3[[1]]))
c<-abs(dec[1])+dec[2]/60+dec[3]/3600
c<-ifelse(dec[1]<0,-c,c)
return(c)
}
convert<-function(coord){
tmp1=strsplit(coord,"D")
tmp2=strsplit(tmp1[[1]][2],"M")
tmp3=strsplit(tmp2[[1]][2],"\S")
dec=c(as.numeric(tmp1[[1]][1]),as.numeric(tmp2[[1]][1]),as.numeric(tmp3[[1]]))
c<-abs(dec[1])+dec[2]/60+dec[3]/3600
c<-ifelse(dec[1]<0,-c,c)
return(c)
}
convert<-function(coord){
tmp1=strsplit(coord,"°")
tmp2=strsplit(tmp1[[1]][2],"'")
tmp3=strsplit(tmp2[[1]][2],"\"")
dec=c(as.numeric(tmp1[[1]][1]),as.numeric(tmp2[[1]][1]),as.numeric(tmp3[[1]]))
c<-abs(dec[1])+dec[2]/60+dec[3]/3600
c<-ifelse(dec[1]<0,-c,c)
return(c)
}
convert<-function(coord){
tmp1=strsplit(coord,"D")
tmp2=strsplit(tmp1[[1]][2],"M")
tmp3=strsplit(tmp2[[1]][2],"\S")
dec=c(as.numeric(tmp1[[1]][1]),as.numeric(tmp2[[1]][1]),as.numeric(tmp3[[1]]))
convert<-function(coord){
tmp1=strsplit(coord,"D")
tmp2=strsplit(tmp1[[1]][2],"M")
tmp3=strsplit(tmp2[[1]][2],"S")
dec=c(as.numeric(tmp1[[1]][1]),as.numeric(tmp2[[1]][1]),as.numeric(tmp3[[1]]))
c<-abs(dec[1])+dec[2]/60+dec[3]/3600
c<-ifelse(dec[1]<0,-c,c)
return(c)
}
convert (cz.nic.raw$lat)
View(coord)
View(cz.nic.raw)
install.packages ("sp")
install.packages("sp")
install.packages("sp")
install.packages("sp")
install.packages ("sp")
install.packages("sp")
install.packages("sp")
install.packages("sp")
install.packages("sp")
install.packages("sp")
library("sp", lib.loc="~/R/win-library/3.1")
convert (cz.nic.raw$lat[1,])
convert (cz.nic.raw$lat[1,4])
head(cz.nic.raw)
convert (cz.nic.raw$lat[1,5])
convert (cz.nic.raw$lat[1,6])
convert (cz.nic.raw$lat[1,6])
convert (cz.nic.raw$lat[2,6])
convert (cz.nic.raw$lat[6,2])
lat=dms2deg ("49D56M48.183S", sep="DMS")
library (celestial)
convert (cz.nic.raw$lat[6,2])
lat=dms2deg ("49D56M48.183S", sep="DMS")
lat
lat=dms2deg ("cz.nic.raw$lat", sep="DMS")
for (i in 1:85) {
lat = dms2deg("cz.nic.raw$lat", sep="DMS")
}
lat = dms2deg("cz.nic.raw$lat[1]", sep="DMS")
for (i in 1:85) {
lat = dms2deg(cz.nic.raw$lat[1], sep="DMS")
}
lat = dms2deg(cz.nic.raw$lat, sep="DMS")
for (i in 1:85) {
lat = dms2deg(cz.nic.raw$lat[i], sep="DMS")
}
for (i in 1:85) {
lat = dms2deg("cz.nic.raw$lat[i]", sep="DMS")
}
}
for (i in 1:85) {
lat = cz.nic.raw$lat[i]
}
lat
for (i in 1:85) {
lat = cz.nic.raw$lat[i,]
}
lat
for (i in 1:85) {
lat = cz.nic.raw$lat[,i]
}
for (i in 1:85) {
lat = cz.nic.raw$lat[i]
}
lat
for (i in 1:90) {
lat = cz.nic.raw$lat[i]
}
lat
for (i in 1:90) {
lat = dms2deg (print (cz.nic.raw$lat[i]), sep="DMS")
}
lat
lat=dms2deg ("cz.nic.raw$lat[1]", sep="DMS")
lat=dms2deg ("cz.nic.raw$lat[,1]", sep="DMS")
lat=dms2deg ("cz.nic.raw$lat[1,]", sep="DMS")
lat=dms2deg ("cz.nic.raw$lat[1]", sep="DMS")
lat=dms2deg (cz.nic.raw$lat[1], sep="DMS")
cz.nic.raw = read.csv ("nicr.czech.csv", header= TRUE, sep=";")
head(cz.nic.raw)
convert<-function(coord){
tmp1=strsplit(coord,"°")
tmp2=strsplit(tmp1[[1]][2],"'")
tmp3=strsplit(tmp2[[1]][2],"\"")
dec=c(as.numeric(tmp1[[1]][1]),as.numeric(tmp2[[1]][1]),as.numeric(tmp3[[1]]))
c<-abs(dec[1])+dec[2]/60+dec[3]/3600
c<-ifelse(dec[1]<0,-c,c)
return(c)
}
convert (cz.nic.raw$lat)
convert<-function(coord){
tmp1=strsplit(coord,"°")
tmp2=strsplit(tmp1[[1]][2],"'")
tmp3=strsplit(tmp2[[1]][2],"\"")
dec=c(as.numeric(tmp1[[1]][1]),as.numeric(tmp2[[1]][1]),as.numeric(tmp3[[1]]))
c<-abs(dec[1])+dec[2]/60+dec[3]/3600
c<-ifelse(dec[1]<0,-c,c)
return(c)
}
convert (cz.nic.raw$lat)
dms_to_deg<- function (dms){
splitdms <- strsplit(as.character(dms), ":")
deg <- as.numeric(substring(splitdms[[1]][1],2,4))
sec <- as.numeric(splitdms[[1]][3])+(as.numeric(splitdms[[1]][2])*60)
secasdeg <- sec/3600
dd <- deg + secasdeg
return (dd)
}
#### End Function ###
### Import coordinates in decimal degrees
### Tab delimited file two columns "latitude" and "longitude"
### Demo uses edeninstitutions.txt found in zipfile
coord<-read.csv("nicr.czech.csv",sep=";",header=T)
### Define matrix for results:
output<-matrix(NA,nrow(coord),2)
colnames(output)<-c("dd.lat","dd.lon")
for (i in 1: nrow(coord)){
### Ensure Input non-negative and define Direction Prefix:
if (substr(coord$dms.lat[i],1,1) == "N") {
dms_to_deg(coord$dms.lat[i]) ->output[i,1]
}
else {
0 - dms_to_deg(coord$dms.lat[i]) ->output[i,1]
}
if (substr(coord$dms.lon[i],1,1) == "E") {
dms_to_deg(coord$dms.lon[i]) ->output[i,2]
}
else {
0 - dms_to_deg(coord$dms.lon[i])->output[i,2]
}
}
coord<-read.csv("nicr.czech.csv",sep=";",header=T)
### Define matrix for results:
output<-matrix(NA,nrow(coord),2)
colnames(output)<-c("dd.lat","dd.lon")
### For each line in input check +/- value then add  N/E/S/W specifier
### Then apply function using value modulus if it is a negative value
for (i in 1: nrow(coord)){
### Ensure Input non-negative and define Direction Prefix:
if (substr(coord$dms.lat[i],1,1) == "N") {
dms_to_deg(coord$dms.lat[i]) ->output[i,1]
}
else {
0 - dms_to_deg(coord$dms.lat[i]) ->output[i,1]
}
if (substr(coord$dms.lon[i],1,1) == "E") {
dms_to_deg(coord$dms.lon[i]) ->output[i,2]
else {
0 - dms_to_deg(coord$dms.lon[i])->output[i,2]
}
### Save output to Tab delimited file output.txt
write.table(output, file="edeninstitutions_dd.txt", row.name=F, col.name=T, sep="\t")
}
}
################################################################################
###                                                                          ###
### Conversion from DMS to Decimal Degrees                                   ###
###                                                                          ###
### 1. Extract whole degrees                                                 ###
### 2. Calculate the total number of seconds min*60 + secs                   ###
### 3. The fractional part is total number of seconds divided by 3600.       ###
### 4. Add fractional degrees to whole degrees to produce the final result   ###
### 5. If it is a Southern latitude or a Western longitude coordinate        ###
###    negate the result.                                                    ###
###                                                                          ###
### This script/demo was written by ERGO/Euro-AEGIS as a resource for the    ###
### partners in the EDENext FP7 project: Biology and control of vector-borne ###
### infections in Europe.                                                    ###
###                                                                          ###
### It was ammended from the original deg_to_dms script written by           ###
### Daniela Cianci (University of Utrecht)                                   ###
###                                                                          ###
### It can be freely distributed and re-used by all but please credit        ###
### Daniela Cianci and http://www.edenextdata.com                            ###
###                                                                          ###
### Author: Neil Alexander                                                   ###
### Contact: neil.alexander@zoo.ox.ac.uk                                     ###
### website: http://www.edenextdata.com                                      ###
###                                                                          ###
################################################################################
###                                                                          ###
###                                                                          ###
### Function to multiply out decimal degrees to DMS format
### Then concatenate output
dms_to_deg<- function (dms){
splitdms <- strsplit(as.character(dms), ":")
deg <- as.numeric(substring(splitdms[[1]][1],2,4))
sec <- as.numeric(splitdms[[1]][3])+(as.numeric(splitdms[[1]][2])*60)
secasdeg <- sec/3600
dd <- deg + secasdeg
return (dd)
}
#### End Function ###
### Import coordinates in decimal degrees
### Tab delimited file two columns "latitude" and "longitude"
### Demo uses edeninstitutions.txt found in zipfile
coord<-read.csv("nicr.czech.csv",sep=";",header=T)
### Define matrix for results:
output<-matrix(NA,nrow(coord),2)
colnames(output)<-c("dd.lat","dd.lon")
### For each line in input check +/- value then add  N/E/S/W specifier
### Then apply function using value modulus if it is a negative value
for (i in 1: nrow(coord)){
### Ensure Input non-negative and define Direction Prefix:
if (substr(coord$dms.lat[i],1,1) == "N") {
dms_to_deg(coord$dms.lat[i]) ->output[i,1]
}
else {
0 - dms_to_deg(coord$dms.lat[i]) ->output[i,1]
}
if (substr(coord$dms.lon[i],1,1) == "E") {
dms_to_deg(coord$dms.lon[i]) ->output[i,2]
}
else {
0 - dms_to_deg(coord$dms.lon[i])->output[i,2]
}
}
### Save output to Tab delimited file output.txt
write.table(output, file="edeninstitutions_dd.txt", row.name=F, col.name=T, sep="\t")
################################################################################
###                                                                          ###
### Conversion from DMS to Decimal Degrees                                   ###
###                                                                          ###
### 1. Extract whole degrees                                                 ###
### 2. Calculate the total number of seconds min*60 + secs                   ###
### 3. The fractional part is total number of seconds divided by 3600.       ###
### 4. Add fractional degrees to whole degrees to produce the final result   ###
### 5. If it is a Southern latitude or a Western longitude coordinate        ###
###    negate the result.                                                    ###
###                                                                          ###
### This script/demo was written by ERGO/Euro-AEGIS as a resource for the    ###
### partners in the EDENext FP7 project: Biology and control of vector-borne ###
### infections in Europe.                                                    ###
###                                                                          ###
### It was ammended from the original deg_to_dms script written by           ###
### Daniela Cianci (University of Utrecht)                                   ###
###                                                                          ###
### It can be freely distributed and re-used by all but please credit        ###
### Daniela Cianci and http://www.edenextdata.com                            ###
###                                                                          ###
### Author: Neil Alexander                                                   ###
### Contact: neil.alexander@zoo.ox.ac.uk                                     ###
### website: http://www.edenextdata.com                                      ###
###                                                                          ###
################################################################################
###                                                                          ###
###                                                                          ###
### Function to multiply out decimal degrees to DMS format
### Then concatenate output
dms_to_deg<- function (dms){
splitdms <- strsplit(as.character(dms), ":")
deg <- as.numeric(substring(splitdms[[1]][1],2,4))
sec <- as.numeric(splitdms[[1]][3])+(as.numeric(splitdms[[1]][2])*60)
secasdeg <- sec/3600
dd <- deg + secasdeg
return (dd)
}
#### End Function ###
### Import coordinates in decimal degrees
### Tab delimited file two columns "latitude" and "longitude"
### Demo uses edeninstitutions.txt found in zipfile
coord<-read.csv("nicr.czech.csv",sep=";",header=T)
### Define matrix for results:
output<-matrix(NA,nrow(coord),2)
colnames(output)<-c("dd.lat","dd.lon")
### For each line in input check +/- value then add  N/E/S/W specifier
### Then apply function using value modulus if it is a negative value
for (i in 1: nrow(coord)){
### Ensure Input non-negative and define Direction Prefix:
if (substr(coord$dms.lat[i],1,1) == "N") {
dms_to_deg(coord$dms.lat[i]) ->output[i,1]
}
else {
0 - dms_to_deg(coord$dms.lat[i]) ->output[i,1]
}
if (substr(coord$dms.lon[i],1,1) == "E") {
dms_to_deg(coord$dms.lon[i]) ->output[i,2]
}
else {
0 - dms_to_deg(coord$dms.lon[i])->output[i,2]
}
}
### Save output to Tab delimited file output.txt
write.table(output, file="edeninstitutions_dd.txt", row.name=F, col.name=T, sep="\t")
################################################################################
###                                                                          ###
### Conversion from Decimal Degree to DMS                                    ###
###                                                                          ###
### 1. The whole units of degrees will remain the same                       ###
###    (i.e. in 121.135 longitude, start with 121  ).                        ###
### 2. Multiply the decimal by 60 (i.e. .135 * 60 = 8.1).                    ###
### 3. The whole number becomes the minutes (8').                            ###
### 4. Take the remaining decimal and multiply by 60. (i.e. .1 * 60 = 6).    ###
### 5. The resulting number becomes the seconds (6"). Seconds can remain as  ###
###    a decimal.                                                            ###
### 6. Take your three sets of numbers and put them together, Adding         ###
###    seperating values with : (i.e. 121:8:6" longitude)                    ###
### 7. Depending on whether the source number was a latitudinal or           ###
###    longitudinal coordinate, and the sign of the number, add the          ###
###    N/S/E/W specifier                                                     ###
###                                                                          ###
### This script/demo was written by Daniela Cianci and was kindly shared     ###
### with partners in the EDENext FP7 project: Biology and control of         ###
### vector-borne infections in Europe.                                       ###
###                                                                          ###
### It can be freely distributed and re-used by all but please credit        ###
### Daniela Cianci and http://www.edenextdata.com                            ###
###                                                                          ###
### Author: Daniela Cianci (University of Utrecht)                           ###
### Contact: neil.alexander@zoo.ox.ac.uk                                     ###
### website: http://www.edenextdata.com                                      ###
###                                                                          ###
################################################################################
###                                                                          ###
###                                                                          ###
### Function to multiply out decimal degrees to DMS format
### Then concatenate output
deg_to_dms<- function (degfloat){
deg <- as.integer(degfloat)
minfloat <- 60*(degfloat - deg)
min <- as.integer(minfloat)
secfloat <- 60*(minfloat - min)
### Round seconds to desired accuracy:
secfloat <- round(secfloat, digits=3 )
### After rounding, the seconds might become 60
### The following if-tests are not necessary if no
### rounding is done.
if (secfloat == 60) {
min <- min + 1
secfloat <- 0
}
if (min == 60){
deg <- deg + 1
min <- 0
}
dm<-paste(deg,min,sep=":")
dms<-paste(dm,secfloat,sep=":")
return (dms)
}
#### End Function ###
### Import coordinates in decimal degrees
### Tab delimited file two columns "latitude" and "longitude"
### Demo uses edeninstitutions.txt found in zipfile
coord<-read.csv("nicr.czech.csv",sep=";",header=T)
### Define matrix for results:
output<-matrix(NA,nrow(coord),2)
colnames(output)<-c("dms.lat","dms.lon")
### For each line in input check +/- value then add  N/E/S/W specifier
### Then apply function using value modulus if it is a negative value
for (i in 1: nrow(coord)){
### Ensure Input non-negative and define Direction Prefix:
if (coord$latitude[i] < 0) {
paste("S",deg_to_dms(Mod(coord$latitude[i])),sep="") ->output[i,1]
}
else {
paste("N",deg_to_dms(coord$latitude[i]),sep="") ->output[i,1]
}
if (coord$longitude[i] < 0) {
paste("W",deg_to_dms(Mod(coord$longitude[i])),sep="") ->output[i,2]
}
else {
paste("E",deg_to_dms(coord$longitude[i]),sep="")->output[i,2]
}
}
### Save output to Tab delimited file output.txt
write.table(output, file="edeninstitutions_dms.txt", row.name=F, col.name=T, sep="\t")
tm1=strsplit (cz.nic.raw$lat,"°")
cz.nic.raw = read.csv ("nicr.czech.csv", header= TRUE, sep=";")
tm1=strsplit (cz.nic.raw$lat,"D")
lat=cz.nic.raw$lat
lat
tm1=strsplit (lat,"D")
as.character (lat)
tm1=strsplit (lat,"D")
